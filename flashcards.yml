---
cards:
  epmty:
    def: epmty
    tags: epmty
  2d_dynamic_programming:
    def: 'uses a 2d array of dividing subproblems, usually involves 2 lists of options '
    tags:
      - ''
  Bitwise_Xor:
    def: this is a pattern that utilizes the properties that bitwies xor is one and only one of L or R to be honest these seem to all be bitwise tricks, you need to know th things of all of them
    tags:
      - patterns
  Cap theorem:
    def: Consistency  - all nodes are consistent Availability  - always accessible Partitions  - you can split things up  -compromises are made between these 3, cant all be @ %100
    tags:
      - System Design
  epmty:
    def: epmty
    tags: 
      - epmty
  In-place_Linked_List_reversal:
    def: gotta read into a new list
    tags:
      - linked list
  K_Way_Merge:
    def: this pattern depends upon the ability of a min heap to merge thins in log(N) time
    tags:
      - it takes log(N) to add something to a min heap
  Knapsack_DynamicProgramming:
    def: ''
    tags:
      - tree
  Modiified_Binary_search:
    def: 'modify bin search to '
    tags:
      - tree
  Subsets:
    def: 'permutations and combinations of a given thing usually solved with a BFS of stuff'
    tags:
      - ''
  Top_K_Elements:
    def: ''
    tags:
      - ''
  Topological_Sort:
    def: ''
    tags:
      - ''
  Tree_BFS:
    def: ''
    tags:
      - ''
  Tree_DFS:
    def: ''
    tags:
      - ''
  Two_Heaps:
    def: ''
    tags:
      - ''
  bottom_up_dynamic_programming:
    def: building subproblems up to larger ones good for when you know you will need to do them in  ascending order of the tree
    tags:
      - ''
  byzantine_failure:
    def: a node exhibits arbitrary behaviour and failure to follow expected path
    tags:
      - ''
  crash_failure:
    def: fails but communication stops
    tags:
      - ''
  cyclic_sort:
    def: 'a method of in place sorting the swap '
    tags:
      - ''
  fail_stop_failure:
    def: node halts and the stop is detected
    tags:
      - ''
  hashmap:
    def: so in python you basically use a dictionary, you can make a function to make keys
    tags:
      - ''
  inorder traversal:
    def: left - root - right
    tags:
      - ''
  memoization:
    def: 'caching the answers to subproblems and doing them '
    tags:
      - ''
  merge_intervals:
    def: sets of intervals () having them sorted by start and then iterating handle overlapps
    tags:
      - ''
  omission_failure:
    def: stopping of responses
    tags:
      - ''
  preorder traversal:
    def: root-left-right
    tags:
      - ''
  sliding_windows:
    alt:
      - 2 pointers
      - fast
    def: 'left and right pointers move scroll across subsets to find matching subsets usually ends up O(N) time '
    tags:
      - ''
  top_down_dynamic_programming:
    def: for when you're starting at the top of a decision tree
    tags:
      - ''